#!/usr/bin/env python3
"""
Copyright (c) Facebook, Inc. and its affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
"""
import datetime
import json
import logging
import os
import pwd
import uuid
from typing import List, Sequence

import nbformat

from .problem import Problem
from .solver import PerformanceSummary, SingleSampleSummary, Solver
from .types import RunOpts, Split


logger = logging.getLogger(__name__)


SYNC_FILE = "/tmp/frl_dist_ml_sync" + "." + pwd.getpwuid(os.getuid()).pw_name


class LocalSolver:
    @staticmethod
    def _get_cells_for_plots(
        summaries: Sequence[SingleSampleSummary], split: Split, group_name: str
    ) -> List[nbformat.notebooknode.NotebookNode]:
        return [
            nbformat.v4.new_code_cell(
                f"""
# group: "{group_name}" split: "{split.value}" source: "{summary.source}"
import plotly.offline as py
import json
py.init_notebook_mode()
py.iplot(json.loads('{json.dumps(summary.plot)}'))
        """.strip()
            )
            for summary in summaries
        ]

    @classmethod
    def _get_epoch_cells(
        cls, epoch: int, epoch_summary: PerformanceSummary
    ) -> List[nbformat.notebooknode.NotebookNode]:
        cells: List[nbformat.notebooknode.NotebookNode] = []
        for split, split_summary in epoch_summary.performance.items():
            cells += cls._get_cells_for_plots(
                split_summary.sample_summary.random.summaries, split, "random"
            )
            cells += cls._get_cells_for_plots(
                split_summary.sample_summary.worst.summaries, split, "worst"
            )

        return cells

    @classmethod
    def solve(
        cls, run_opts: RunOpts, problem: Problem, save_notebook: bool = False
    ) -> PerformanceSummary:
        with open(SYNC_FILE, "w+"):
            pass
        group_name = uuid.uuid4().hex
        init_method = "file://" + SYNC_FILE
        logger.info("Group name: " + str(group_name))

        cells = [
            nbformat.v4.new_markdown_cell(
                "## Automatically generated by FRL Distributed ML Scaffold"
            )
        ]

        epoch_summary: PerformanceSummary
        for epoch, epoch_summary in enumerate(
            Solver.solve(
                run_opts, problem, group_name=group_name, init_method=init_method
            )
        ):
            is_final_epoch = (epoch + 1) == run_opts.nEpochs
            if not is_final_epoch:
                continue

            cells += cls._get_epoch_cells(epoch, epoch_summary)

        if save_notebook:
            nb = nbformat.v4.new_notebook(cells=cells)
            notebook_dir = os.path.expanduser("~/local/notebooks/frl_dist_ml")
            os.makedirs(notebook_dir, exist_ok=True)

            notebook_filename = "%s_%s.ipynb" % (
                str(problem.__class__),
                str(datetime.datetime.now()),
            )
            notebook_path = os.path.join(notebook_dir, notebook_filename)
            with open(notebook_path, "w", encoding="utf-8") as f:
                nbformat.write(nb, f, version=4)

            logger.info("Notebook written to %s" % notebook_path)
        return epoch_summary
